---
title: "Functions and Tidy Data"
author: "Biol 607"
date: "10/4/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning=FALSE,
                      message=FALSE, 
                      eval = FALSE)
```

**1.** Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.

```{r}
one_boot <- function(vec){
  sample(vec, length(vec), replace = TRUE)
}

one_boot(1:10)

```

**2.** Write a function that given a vector of values  a request for some number of bootstraps (let's call the parameter R), and a sample statistic function (e.g., `mean`, `IQR`, etc.) returns R number of values of that statistic. Have it default to R = 1000 and the function is mean. Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? Compare to the actual mean of the vector.

*make sure you are using the function(s) you wrote in #1*

```{r}
boot_reps <- function(vec, R = 1000, fun = mean){
  replicate(R, fun(one_boot(vec)))
}

boot_reps(1:10, R = 10)

mean(1:10)

```

**3.** Write a function that, given a vector of values  a request for some number of bootstraps, and a sample statistic function, returns the original value of the statistic as applied to the vector, the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic).


*make sure you are using the function(s) you wrote in #1 and/or #2*

```{r}
boot_stat <- function(vec, R = 1000, fun = mean){
  samp <- boot_reps(vec, R, fun)
  
  dplyr::tibble(stat = fun(vec),
             boot_stat = mean(samp),
             se = sd(samp),
             lwr = quantile(samp, 0.025),
             upr = quantile(samp, 0.975),
             bias = fun(vec) - mean(samp))
  
}

boot_stat(1:10, fun = mean)
```

<!--
**4.** Write a function that, given a mean and standard deviation of a population along with a sample size and draws a sample from the population and then returns a bootstrapped requested sample statistic and CI for some R number of bootstrap draws. Have it default to mean as the same statistic. Demonstrate that it works for the SD using three draws from the population (i.e., run the function 3 times). Maybe, you know, bind it in a single data frame somehow? 

```{r}
get_pop_samp_stat <- function(m, s, n,
                              R = 1000, fun = mean){
  one_samp <- rnorm(n, m, s)
  
  boot_stat(one_samp, R = R, fun = fun)
}

library(purrr)
map_df(1:3, get_pop_samp_stat,
       m = 3, s = 2, n = 5, fun = sd)
```

**5.** Cool. Now, get 100 simulated statistics using the above function from a population with a mean of 3, sd of 2, and sample size of 10. Calculate the SD as your sample statistic. What % of the time is the true sd of 2 contained in the confidence interval (note, there are a LOT of ways to do this)? Does that fit with your expectation?

```{r}
library(dplyr)

sds <- map_df(1:1000, get_pop_samp_stat,
       m = 3, s = 2, n = 15, fun = sd)

sds %>%
  mutate(lwr_ok = lwr<2,
         upr_ok = upr>2,
         covers = (lwr_ok + upr_ok) == 2) %>%
  pull(covers) %>%
  sum(.)/1000
```

**5a.** Do you get a different answer with just the statistic +/- 2SE?

```{r}
sds %>%
  mutate(lwr_ok = stat-2*se < 2,
         upr_ok = stat+2*se > 2,
         covers = (lwr_ok + upr_ok) == 2) %>%
  pull(covers) %>%
  sum(., na.rm=TRUE)/1000
```

**5 EC.** Plot this phenomena. Highlight which CIs fail to overlap the true value of the SD.
-->

**4.** FiveThirtyEight keeps a great archive of poll data at https://projects.fivethirtyeight.com/polls/. The presidential general election polling data is freely available at https://projects.fivethirtyeight.com/polls-page/president_polls.csv with question, poll id, and cycle defining a unique poll. 

&nbsp; &nbsp; **4a**. Download and look at the data. Is it long or wide?

```{r}
polls <- read.csv("https://projects.fivethirtyeight.com/polls-page/president_polls.csv")

head(polls)

#it is long
```

&nbsp; &nbsp; **4b**. Get just the polling data for this last week (from 9/29 to today). Filter on `start_date`. Also filter down to just Biden and Trump (see `candidate_name` or `answer`). Extra credit for using {lubridate} for this, but you can just do a messy %in% string match.

```{r}
polls_filtered <- polls %>%
  filter(start_date %in% c("9/29/20",
                           "9/30/20",
                           "9/31/20",
                           "10/1/20",
                           "10/2/20",
                           "10/3/20"
                           )) %>%
  filter(candidate_name %in% c("Joseph R. Biden Jr.",
                               "Donald Trump") )
```

&nbsp; &nbsp; **4c**. OK, this is your sample. What's the bootstrapped average percentage for each candidate for nationwide polls (state == "")? Note, this answer will not match 538 given their weighting by poll trustworthiness. 

```{r}
polls_filtered %>%
  filter(state == "") %>%
  group_by(answer) %>%
  summarize(boot_stat(pct, fun))
```

&nbsp; &nbsp; **4d**. What is the average difference between the two candidates by state and national polls? Note, you'll need to make this a wide data frame to answer! And, well, try the pivot without this advice first, but then....

make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs

```{r}
library(tidyr) 

polls_filtered %>%
  mutate(ID = paste0(question_id, poll_id, state)) %>%
  select(ID, state, answer, sample_size, pct) %>%
  pivot_wider(names_from = answer,
              values_from = pct) %>%
  mutate(diff = Biden - Trump) %>%
  filter(!is.na(diff)) %>%
  group_by(state) %>%
  summarize(boot_stat(diff))
```

**5.** `replicate()` has been our friend, but we've always had to be a little hacky with it. We've either had to fold in means, or use tricksy functions like colMeans and the like.

BUT - what's interesting about `replicate()` is that, if you ask it to turn back raw draws from a random number generator - or anything with more than one value - it gives you a matrix or array.

&nbsp; &nbsp; **5a.** So, I want you to, using the mean and SD of Biden's national polling average (you'll need to calculate it!) from above, simulate 1000 draws from that population with a sample size of 50. What are the dimensions of the object. What are in the rows and columns?

```{r}
m <- 48.5
s <- 2.82

bsims <- replicate(1000, rnorm(50, m, s))

dim(bsims)

#50 rows - rows are draws for 1 sim
#1000 cols, cols are sims
```

&nbsp; &nbsp; **5b.** Yuck. Can you turn this into something usable? Say, first make it a tibble or data frame, and then pivot it to long, such that you end up with a column that has an identifier for sim and a column with a single value from that sim?

(Oh, and for all columns, `cols = everything()`)

```{r}
long_bsims <- bsims %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               names_to = "sim", 
               values_to = "pct")
```

&nbsp; &nbsp; **5c.** For each sim, what's the bootsrapped mean and CI? Plot it! And tell us how often it's greater than the initial mean. E.C. for the plot showing the stats in order from low to high.

```{r}
library(ggplot2)

sim_means <- long_bsims %>%
  group_by(sim) %>%
  summarize(boot_stat(pct))

sim_means <- sim_means %>%
  mutate(sim = forcats::fct_reorder(sim, stat))

ggplot(sim_means,
        aes(x = sim,
            y = stat,
            ymin = lwr,
            ymax = upr)) +
  geom_pointrange() +
  scale_x_discrete(labels = NULL) +
  geom_hline(yintercept = 48.5, color = "red", lty = 2)
  
```

&nbsp; &nbsp; **5d.** So.... what is that plot showing? What are the concepts involved?
```{r}
# something about Cis and # of times they don't contain the "true" value of the mean.
```

**EC** 3 bonus point for each awesome quality visualization of the general polling data. There is a LOT there, so look carefully before you leap.